#!/bin/env ruby
# coding: utf-8
require 'date'
require 'csv'
require 'optparse'
require 'optparse/uri'
require './scheme'

Languages = ['EN'] #,'ES','FR','DE','ZH']
Prefixes = {
}

subfield_delim = ';'

options = {}

scheme_modified_date = Date.today.to_s
base_uri = nil

OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  opts.on('-u', '--base-uri [URI]', URI, "Set base URI") do |v|
    base_uri = v.to_s
  end
end.parse!


# Makes an autovivifying Hash.
# Adapted from https://t-a-w.blogspot.com/2006/07/autovivification-in-ruby.html
def autovivifying_hash
  Hash.new do |ht, k|
    ht[k] = autovivifying_hash
  end
end

class Term < Scheme::Term
  attr_reader :id
  def initialize(base_uri, id, properties:)
    super(uri: base_uri+id.to_s,
          scheme: base_uri,
          properties: properties.transform_keys do |key|
            key
          end)
    @id = id
  end
end

# Iterate over the input TSV, and build a nested hash index of
# terms -> properties -> language code -> phrase
term_index = autovivifying_hash
CSV.new($stdin, col_sep: "\t", headers: true, liberal_parsing: true).each do |row|
  term, property = row.fields('term', 'property')

  # remove nulls/padding
  term = term.to_s.strip
  property = property.to_s.strip

  # remove the term and property fields
  terms = row.to_h.except('term', 'property')

  # split multi-value items (those with a subfield delimiter)
  terms = terms.to_a.collect do |k, v|
    # Sanitise the terms,
    # remove spurious whitespace
    k = k.to_s.strip
    v = v.to_s.strip
    
    ary = if v
            # Here we use a negative lookbehind anchor to ensure we only match
            # subfield_delims not preceeded by an escape character.
            v.split(/(?<!\\)#{Regexp.quote(subfield_delim)}/)
              .collect {|it| it.gsub(/\\(.)/, '\1') } # unescape
          else
            []
          end
    
    [k, ary]
  end
  
  term_index[term][property] = terms.to_h
end
   
if term_index.empty?
  raise "Input phrasetab gives an emtpy term index!"
end

# Get the global properties for the vocab (these have no term field)
scheme_props = term_index.delete('')

props_base_uri = scheme_props.delete('base_uri')
base_uri = props_base_uri[""].first if base_uri.to_s.empty?

abort "You must supply a base URI" unless base_uri

scheme = Scheme.new(
  base_uri: base_uri,
  title: scheme_props.delete('dc:title'),
  description: scheme_props.delete('dc:description'),
  modified: scheme_modified_date,
  created: scheme_props.delete('dcterms:created')[""].first,
  prefixes: Prefixes,
  properties: scheme_props.transform_keys {|k| k.to_sym },
  terms: term_index.to_a.collect do |k, v|
    Term.new(base_uri, k, properties: v)
  end,
)


scheme.write

